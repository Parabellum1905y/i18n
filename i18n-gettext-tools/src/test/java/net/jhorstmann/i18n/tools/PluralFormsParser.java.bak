package net.jhorstmann.i18n.tools;

import net.jhorstmann.i18n.tools.expr.ConstantExpression;
import net.jhorstmann.i18n.tools.expr.Expression;
import net.jhorstmann.i18n.tools.expr.NotExpression;
import net.jhorstmann.i18n.tools.expr.NumberExpression;

public class PluralFormsParser {

    private String value;
    private int idx;
    private int numPlurals;
    private Expression expression;

    public PluralFormsParser(String value) {
        this.value = value;
    }

    private boolean isEOF() {
        return idx >= value.length();
    }

    private void consume(String expected) throws ParseException {
        if (isEOF()) {
            throw new ParseException("Unexpected end of input");
        }
        int len = expected.length();
        if (value.regionMatches(idx, expected, 0, len)) {
            idx += len;
        } else {
            throw new ParseException("Expected '" + expected + "'");
        }
    }

    private void consume(char expected) throws ParseException {
        if (isEOF()) {
            throw new ParseException("Unexpected end of input");
        }
        char ch = value.charAt(idx);
        if (ch == expected) {
            idx++;
        } else {
            throw new ParseException("Expected '" + expected + " but got '" + ch + "'");
        }
    }

    private char peek() throws ParseException {
        if (isEOF()) {
            throw new ParseException("Unexpected end of input");
        }
        return value.charAt(idx);
    }

    private char next() throws ParseException {
        if (isEOF()) {
            throw new ParseException("Unexpected end of input");
        }
        return value.charAt(idx++);
    }

    private boolean isWhitespace(char ch) {
        return ch == ' ' || ch == '\t';
    }

    private void skipWhitespace() {
        while (isWhitespace(value.charAt(idx))) {
            idx++;
        }
    }

    private boolean isDigit(char ch) {
        return ch >= '0' && ch <= '9';
    }

    private boolean isDelimiter(char ch) {
        return "!()+-*/%<>=".indexOf(idx) >= 0;
    }

    private boolean isFollowSet(char ch) {
        return isEOF() || isWhitespace(ch) || isDelimiter(ch);
    }

    private int parseInt() throws ParseException {
        int result = 0;
        char ch = peek();
        if (isDigit(ch)) {
            result = ch - '0';
            next();
            while (isDigit(ch = peek())) {
                result = result * 10 + ch - '0';
                next();
            }
            return result;
        } else {
            throw new ParseException("Expected digit but got " + ch);
        }
    }

    private Expression parseExpressionImpl() throws ParseException {
        char ch = peek();
        if (ch == '!') {
            next();
            skipWhitespace();
            return new NotExpression(parseExpression());
        } else if (ch == '(') {
            next();
            skipWhitespace();
            Expression result = parseExpression();
            skipWhitespace();
            consume(')');
            return result;
        } else if (isDigit(ch)) {
            int n = parseInt();
            return new ConstantExpression(n);
        } else if (ch == 'n') {
            next();
            ch = peek();
            if (!isFollowSet(ch)) {
                throw new ParseException("Unexpected '" + ch + "'");
            }
            return new NumberExpression();
        } else {
            throw new ParseException("Unexpected '" + ch + "'");
        }
    }

    private Expression parseExpression() throws ParseException {
        Expression leftExpr = parseExpressionImpl();
        skipWhitespace();
        int ch = peek();
        if (ch == '+') {

        }
        return null;
    }

    private void parse() throws ParseException {
        consume("nplurals");
        skipWhitespace();
        consume('=');
        skipWhitespace();
        numPlurals = parseInt();
        if (numPlurals > 1) {
            consume(';');
            skipWhitespace();
            consume("plural");
            skipWhitespace();
            consume('=');
            skipWhitespace();
            expression = parseExpression();
            skipWhitespace();
            consume(';');
        }
    }
}
